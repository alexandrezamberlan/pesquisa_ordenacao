Veja os vídeos para entender a dinâmica de cada método: https://www.youtube.com/@AlgoRythmics/videos

ORDENAR E PESQUISAR
    - ordenar agiliza a pesquisa
    - classificações de ordenação
        - quanto complexidade (esforço/quantidade de processamento): quantidade de comparações e quantidade de trocas
        - quanto ocupação de memória: principal ou secundária
        - quanto a estabilidade: estáveis e instáveis
C++
    - uso de arquivos .h e sua inclusão em outros programas

MÉTODOS DE ORDENAÇÃO SIMPLES

1) BOLHA - Bubble Sort
Estável
Memória Interna
Alta complexidade (muito esforço) - O(n^2)
A estrutura possui 2 partes/porções (1a é a desordenada; 2a parte é a ordenada)
Adequado para vetores e listas

0   1   2   3   4   5   6
7   1   4   2   3   9   8
1   4   2   3   7   8   9
1   2   3   4   7   8   9
1   2   3   4   7   8   9


0   1   2   3   4   5   6
20  12  10  70  20  11  10
12  10  20  20  11  10  70
10  12  20  11  10  20  70
10  12  11  10  20  20  70
10  11  10  12  20  20  70
10  10  11  12  20  20  70
10  10  11  12  20  20  70

```c#
void bolha(List<> lista) {
    bool houveTroca;
    int tmp;
    int qtdComparacoes = 0, qtdTrocas = 0;

    do {
        houveTroca = False;
        for (int i = 0; i < lista.Count()-1; i++){
            qtdComparacoes++;
            if (lista[i] > lista[i+1]) {
                qtdTrocas++;
                houveTroca = True;
                tmp = lista[i];
                lista[i] = lista[i+1];
                lista[i+1] = tmp;
            }
        }
    } while (houveTroca);
}
````

```java
void bolha(List<> lista) {
    boolean houveTroca;
    int tmp;
    int qtdComparacoes = 0, qtdTrocas = 0;

    do {
        houveTroca = False;
        for (int i = 0; i < lista.size()-1; i++){
            qtdComparacoes++;
            if (lista.get(i) > lista.get(i+1)) {
                qtdTrocas++;
                houveTroca = True;
                tmp = lista.get(i);
                lista.set(i, lista.get(i+1));
                lista.set(i+1, tmp);
            }
        }
    } while (houveTroca);
}
```

```python
def bolha(lista):
    houve_troca = true
    qtd_comparacoes = 0
    qtd_trocas = 0
    while (houve_troca):    
        houveTroca = false
        for i in range (len(lista) - 1):
            qtd_comparacoes+=1
            if (lista[i] > lista[i+1]):
                qtd_trocas+=1
                houve_troca = true
                tmp = lista[i]
                lista[i] = lista[i+1]
                lista[i+1] = tmp
```

Trabalha com o conceito de trocas, ou seja, enquanto houver trocas, o algoritmo não para.
É considerado bolha, porque 'leva' os maiores para o final da estrutura

Observação: se a estrutura estiver ordenada ou quase, o bolha terá excelente desempenho

2) SELEÇÃO - Selection Sort
Instável
Memória Interna
Alta complexidade (muito esforço) - O(n^2)
A estrutura possui 2 partes/porções (1a é a ordenada; 2a parte é a desordenada)
Adequado para vetores e listas

Trabalha com conceito de trocas não contíguas. É considerado seleção porque ele seleciona os menores para
o início da estrutura

Observação: se a estrutura estiver ordenada, o método vai funcionar/processar como se a estrutura estivesse desordenada

0   1   2   3   4   5   6    posMenor = 1
7   1   4   2   3   9   8
1   7   4   2   3   9   8.   posMenor
1   2   4   7   3   9   8
1   2   3   7   4   9   8
1   2   3   4   7   9   8
1   2   3   4   7   9   8
1   2   3   4   7   8   9

```c#
void selecao(List<> lista) {
    int posMenor;
    int qtd_comparacoes = 0, qtd_trocas = 0;
    for (int i = 0; i < lista.Count()-1; i++) {
        posMenor = i;
        for (int j = i+1; j < lista.Count(); j++) {
            qtd_comparacoes++;
            if (lista[j] < lista[posMenor]) {
                posMenor = j;
            }
        }
        if (i != posMenor) {
            qtd_trocas++;
            tmp = lista[i];
            lista[i] = lista[posMenor];
            lista[posMenor] = tmp;
        }
    }
}
```

```java
void selecao(List<> lista) {
    int posMenor;
    int qtd_comparacoes = 0, qtd_trocas = 0;
    for (int i = 0; i < lista.size()-1; i++) {
        posMenor = i;
        for (int j = i+1; j < lista.size(); j++) {
            qtd_comparacoes++;
            if (lista.get(j) < lista.get(posMenor)) {
                posMenor = j;
            }
        }
        if (i != posMenor) {
            qtd_trocas++;
            tmp = lista.get(i);
            lista.set(i, lista.get(posMenor));
            lista.set(posMenor, tmp);
        }
    }
}
```

```python
def selecao(lista):
    qtd_comparacoes = 0
    qtd_trocas = 0
    for i in range(len(lista) - 1):
        posMenor = i
        for j in range(i+1, len(lista)):
            qtd_comparacoes+=1
            if (lista[j] < lista[posMenor]):
                posMenor = j
            
        
        if (i != posMenor):
            qtd_trocas+=1
            tmp = lista[i]
            lista[i] = lista[posMenor]
            lista[posMenor] = tmp        
```


3) INSERÇÃO - Insertion Sort - O(n^2)
Estável
Memória Interna
Alta complexidade - O(n^2)
A estrutura possui 2 partes/porções (1a é a ordenada; 2a parte é a desordenada)
Adequado para vetores e listas

Trabalha com o conceito de inserção na porção inicial, com isso, pode diminuir o número de comparações

Observação: i) se a estrutura estiver ordenada ou quase, o inserção terá excelente desempenho
            ii) atenção a lista deve ser duplamente encadeada



Qual o melhor método de ordenação?
Depende: tamanho da estrutura; de como a estrutura já está previamente ordenada;


4) AGITAÇÃO - Shake Sort ou Cocktail
É baseado no Bolha, ou seja, é uma tentantiva de melhorar o Bolha.
Estável
Memória Interna
A estrutura possui 3 partes/porções (1a é a ordenada pelos menores; 2a é a desordenada; 3a é 
a ordenada pelos maiores)

De fato é a aplicação do bolha da esquerda para direita e depois da direita para esquerda

Há os índices/ponteiros ini e fim que marcam o início e o final da estrutura

Observação: i) se a estrutura estiver ordenada ou quase, o agitação terá excelente desempenho, como o bolha
            ii) atenção a lista deve ser duplamente encadeada  


5) PENTE - Comb Sort
É baseado no Bolha, ou seja, é uma tentantiva de melhorar o Bolha.

ATENÇÃO: a partir deste método, há COMPARAÇÕES a uma distância X. Isso gera uma pré-organização da estrutura,
         diminuindo número de comparações e trocas.

Instável
Memória Interna
A estrutura possui 2 porções/partes (1a é a ordenada; 2a é a desordenada)

Há as variáveis clássicas do bolha: i, houveTroca, tmp.
Há a variável distancia que é calculada pelo tamanho da estrutura dividido por 1.3

Adequado somente para vetores ou estruturas prontas tipo lista de uma linguagem de programação
n = 7
0   1   2   3   4   5   6   
7   1   4   2   3   9   8    distancia = (int)n / 1.3 = 5
7   1   4   2   3   9   8    distancia = distancia / 1.3 = 3
2   1   4   7   3   9   8    distancia = distancia / 1.3 = 2
2   1   3   7   4   9   8    distancia = distancia / 1.3 = 1
1   2   3   4   7   8   9    distancia = 1
1   2   3   4   7   8   9

6) SHELLSORT 
É baseado no Inserção, ou seja, é uma tentativa de melhoria via o uso da ANÁLISE A DISTÂNCIA (tipo pente)
Instável 
Memória Interna

Não é adequado para listas encadeadas


7) QUICKSORT (USA O CONCEITO DE DIVIDIR PARA CONQUISTAR)
Faz parte de uma categoria de métodos de ordenação que utilizam a divisão da estrutura para acelerar a ordenação. Essa divisão é realizada por 
meio de RECURSÃO.
    - A estrutura vai possuir 2 porções: parte esquerda e parte direita, divididas pelo PIVO. Pensar como se fosse uma ÁRVORE BINÁRIA
    - O método possui duas funções: quick (processo recursivo) e o particiona (posiciona/ordena o pivo)



8) MERGESORT (como o quicksort, USA O CONCEITO DE DIVIDIR PARA CONQUISTAR)
Faz parte de uma categoria de métodos de ordenação que utilizam a divisão da estrutura para acelerar a ordenação. Essa divisão é realizada por 
meio de RECURSÃO.

Contudo, diferente do QUICKSORT, o MERGESORT sempre divide a estrutura no meio (vai existir uma variável meio)

    - A estrutura vai possuir 2 porções: parte esquerda e parte direita, divididas pelo MEIO. Pensar como se fosse uma ÁRVORE BINÁRIA
    - O método possui duas funções: merge (processo recursivo) e o intercala (a ordenação vai funcionar no desempilhamento do processo em que intercala e ordena)
    


9) HEAPSORT (método baseado na dinâmica de árvores binárias, contudo em vetor)
    - Heapmáximo: garantir que raiz da subarvore seja maior ou igual que seus filhos. Se isso não ocorrer, fazer as trocas
        filhoEsquerda = posicaoRaiz * 2
        filhoDireita = posicaoRaiz * 2 + 1
    - Troca do primeiro com o último e diminui uma posição o vetor (fim)

    ATENÇÃO: o vetor deve começar na posição 1

    Teste para filho esquerda 
        -> if (vetor[raiz] < vetor[raiz * 2]) { troca }
    Teste para o filho da direita (antes de testar, é preciso ter certeza que o filho exista)
        -> if (raiz * 2 + 1 < n && vetor[raiz] < vetor[raiz * 2 + 1]) { troca }



